package sip

import (
	"context"
	"errors"
	"fmt"
	"github.com/gophertribe/megaphone/input"
	"github.com/gophertribe/megaphone/media"
	"log/slog"
	"reflect"
	"strings"

	"github.com/emiago/sipgo"
	"github.com/emiago/sipgo/sip"
	"github.com/icholy/digest"
	"github.com/pion/sdp/v3"
)

type Credentials struct {
	Username        string
	Password        string
	ContactHostname string
}

type Destination struct {
	Transport string
	ProxyAddr string
}

type Session struct {
	ID      string
	State   int
	Session sdp.SessionDescription
	lastReq *sip.Request
}

func (s *Session) GetID() string {
	return s.ID
}

func (s *Session) Update(req *sip.Request, sd sdp.SessionDescription) {
	s.lastReq = req
	s.Session = sd
}

type MediaQueue interface {
	GetSession(id string) (media.Session, error)
	Enqueue(media.Session) error
}

type Endpoint struct {
	client *sipgo.Client
	ua     *sipgo.UserAgent
	server *sipgo.Server
	queue  MediaQueue
	errors chan error
}

var ErrServerNotStarted = errors.New("server not started")

func NewEndpoint(userAgent string, queue MediaQueue) (*Endpoint, error) {
	ua, err := sipgo.NewUA(sipgo.WithUserAgent(userAgent))
	if err != nil {
		return nil, fmt.Errorf("could not init user agent: %w", err)
	}
	return &Endpoint{
		ua:     ua,
		queue:  queue,
		errors: make(chan error),
	}, nil
}

func (e *Endpoint) Errors() chan<- error {
	return e.errors
}

func (e *Endpoint) Register(ctx context.Context, creds Credentials, dest Destination) error {
	// we have to start the sever before we register i.e. to handle likely OPTIONS request
	if e.server == nil {
		return ErrServerNotStarted
	}

	var err error
	e.client, err = sipgo.NewClient(e.ua)
	if err != nil {
		return fmt.Errorf("could not create client: %w", err)
	}
	var recipient sip.Uri
	err = sip.ParseUri(fmt.Sprintf("sip:%s@%s", creds.Username, dest.ProxyAddr), &recipient)
	if err != nil {
		return fmt.Errorf("could not parse recipient: %w", err)
	}
	req := sip.NewRequest(sip.REGISTER, recipient)
	req.AppendHeader(
		sip.NewHeader("Contact", fmt.Sprintf("<sip:%s@%s>", creds.Username, creds.ContactHostname)),
	)
	req.SetTransport(strings.ToUpper(dest.Transport))

	tx, err := e.client.TransactionRequest(ctx, req)
	if err != nil {
		return fmt.Errorf("failed to create transaction for register request: %w", err)
	}
	defer tx.Terminate()

	res, err := getResponse(tx)
	if err != nil {
		return fmt.Errorf("failed to get response for register request: %w", err)
	}

	slog.Info("sip response status", "status", int(res.StatusCode))
	if res.StatusCode == 401 {
		wwwAuth := res.GetHeader("WWW-Authenticate")
		challenge, err := digest.ParseChallenge(wwwAuth.Value())
		if err != nil {
			return fmt.Errorf("failed to parse challenge from %s: %w", wwwAuth.Value(), err)
		}

		// Reply with digest
		cred, _ := digest.Digest(challenge, digest.Options{
			Method:   req.Method.String(),
			URI:      recipient.Host,
			Username: creds.Username,
			Password: creds.Password,
		})

		authReq := req.Clone()
		authReq.RemoveHeader("Via") // must be regenerated by transport layer
		authReq.AppendHeader(sip.NewHeader("Authorization", cred.String()))

		ctx := context.Background()
		tx, err := e.client.TransactionRequest(ctx, authReq, sipgo.ClientRequestAddVia)
		if err != nil {
			return fmt.Errorf("fail to create transaction for auth request: %w", err)
		}
		defer tx.Terminate()

		res, err = getResponse(tx)
		if err != nil {
			return fmt.Errorf("failed to get response for auth request: %w", err)
		}
	}
	if res.StatusCode != 200 {
		return fmt.Errorf("failed to register to sip proxy: %d", res.StatusCode)
	}
	return nil
}

func (e *Endpoint) Listen(ctx context.Context, proto, addr string) error {
	var err error
	e.server, err = sipgo.NewServer(e.ua)
	e.server.OnInvite(func(req *sip.Request, tx sip.ServerTransaction) {
		contentType := req.ContentType()
		if contentType == nil {
			err := tx.Respond(sip.NewResponseFromRequest(req, sip.StatusBadRequest, "expected Content-Type to be present", nil))
			if err != nil {
				e.error(fmt.Errorf("could not respond to INVITE: %w", err))
			}
		}
		if contentType.Value() != input.ContentTypeSdp {
			err := tx.Respond(sip.NewResponseFromRequest(req, sip.StatusExtensionRequired, "missing sdp info", nil))
			if err != nil {
				e.error(fmt.Errorf("could not respond to INVITE: %w", err))
			}
		}
		var sd sdp.SessionDescription
		err = sd.Unmarshal(req.Body())
		if err != nil {
			e.error(fmt.Errorf("could not decode session description; waiting for another session: %w", err))
			err := tx.Respond(sip.NewResponseFromRequest(req, sip.StatusBadRequest, "could not decode session description", nil))
			if err != nil {
				e.error(fmt.Errorf("could not respond to INVITE: %w", err))
			}
		}
		err = e.RegisterSession(req, sd)
		if err != nil {
		}

		// respond with ack
		err = tx.Respond(sip.NewResponseFromRequest(req, sip.StatusRinging, "", nil))
		if err != nil {

		}
		// wait for the queue to begin session
		err = tx.Respond(sip.NewResponseFromRequest(req, sip.StatusOK, "", nil))
		if err != nil {

		}

	})
	e.server.OnBye(func(req *sip.Request, tx sip.ServerTransaction) {
		// terminate call
	})
	e.server.OnCancel(func(req *sip.Request, tx sip.ServerTransaction) {
		// cancel call that is waiting in queue
	})
	e.server.OnOptions(func(req *sip.Request, tx sip.ServerTransaction) {
		res := sip.NewResponseFromRequest(req, sip.StatusOK, "OK", nil)
		err := tx.Respond(res)
		if err != nil {
			e.error(fmt.Errorf("could not respond to OPTIONS: %w", err))
		}
	})
	err = e.server.ListenAndServe(ctx, proto, addr)
	if err != nil {
		return fmt.Errorf("could not start sip server: %w", err)
	}
	return nil
}

func (e *Endpoint) error(err error) {
	select {
	case e.errors <- err:
	default:
		slog.Error("sip endpoint error", "err", err)
	}
}

func (e *Endpoint) RegisterSession(req *sip.Request, sd sdp.SessionDescription) error {
	dialog, err := sip.UACReadRequestDialogID(req)
	if err != nil {
		return fmt.Errorf("could not establish dialog id: %w", err)
	}
	session, err := e.queue.GetSession(dialog)
	if err != nil {
		if errors.Is(err, media.ErrSessionNotFound) {
			err = e.queue.Enqueue(&Session{
				ID:      dialog,
				Session: sd,
				lastReq: req,
			})
			if err != nil {
				return fmt.Errorf("could not enqueue session: %w", err)
			}
			return nil
		}
		return fmt.Errorf("could not get session from queue: %w", err)
	}
	sipSession, ok := session.(*Session)
	if !ok {
		return fmt.Errorf("invalid session type; got %s instead of sip.Session", reflect.TypeOf(session))
	}
	sipSession.Update(req, sd)
	return nil
}

func getResponse(tx sip.ClientTransaction) (*sip.Response, error) {
	select {
	case <-tx.Done():
		return nil, fmt.Errorf("transaction died")
	case res := <-tx.Responses():
		return res, nil
	}
}
